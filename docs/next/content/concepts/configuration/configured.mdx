---
title: Configured API | Dagster
description: The Configured API offers a way to configure a Dagster entity at runtime.
---

# Configured API

The `configured` API offers a way to configure a Dagster entity at runtime.

## Relevant APIs

| Name                                                        | Description                                  |
| ----------------------------------------------------------- | -------------------------------------------- |
| <PyObject module="dagster" object="configured" decorator /> | The decorator to configure a Dagster entity. |
| <PyObject module="dagster" object="configured" />           | The method to configure a Dagster entity.    |

## Overview

In many cases, the option to configure an entity at runtime is more distracting than helpful, and
it's preferable to supply the entity's configuration at definition time.

The `configured` API offers a way to do this. When invoked on a Dagster entity, it returns an
interchangeable object with the given configuration "baked in". It is available with the following
definitions:

- <PyObject module="dagster" object="ResourceDefinition" />
- <PyObject module="dagster" object="ExecutorDefinition" />
- <PyObject module="dagster" object="SolidDefinition" />
- <PyObject module="dagster" object="CompositeSolidDefinition" />
- <PyObject module="dagster" object="LoggerDefinition" />

---

## Using Configured

There are different ways to invoke `configured` on an entity.

### As a Method on an Entity

You can invoke the `configured` as a method on a given entity.

```python file=/concepts/configuration/configured_example.py startafter=start_configured_marker endbefore=end_configured_marker
from dagster import configured, resource


@resource(config_schema={"region": str, "use_unsigned_session": bool})
def s3_session(_init_context):
    """Connect to S3"""


east_unsigned_s3_session = s3_session.configured(
    {"region": "us-east-1", "use_unsigned_session": False}
)
```

### As a Decorator

We also provides a `configured` decorator that makes it easy to create a function-configured version
of an object. You can find more information in the <PyObject module="dagster" object="configured" decorator />
API reference.

```python file=/concepts/configuration/configured_example.py startafter=start_configured_decorator_marker endbefore=end_configured_decorator_marker
@configured(s3_session)
def west_unsigned_s3_session(_init_context):
    return {"region": "us-west-1", "use_unsigned_session": False}
```

### As a Standalone API

If the config that will be supplied to the object is constant, you may alternatively invoke this and
call the result with a dict of config values to be curried. You can find more information in
the <PyObject module="dagster" object="configured" decorator /> API reference.

```python file=/concepts/configuration/configured_example.py startafter=start_configured_method_marker endbefore=end_configured_method_marker
west_signed_s3_session = configured(s3_session)(
    {"region": "us-west-1", "use_unsigned_session": False}
)
```

## Examples

### Partially filling the configuration

In other cases, it's useful to partially fill out configuration at definition time and leave other
configuration for runtime. For these cases, `configured` can be used as a decorator, accepting a
function that translates from runtime config to config that satisfies the entity's config schema.
It returns an entity with the "outer" config schema as its schema.

```python file=/concepts/configuration/config_map_example.py
from dagster import configured, resource


@resource(config_schema={"region": str, "use_unsigned_session": bool})
def s3_session(_init_context):
    """Connect to S3"""


@configured(s3_session, config_schema={"region": str})
def unsigned_s3_session(config):
    return {"region": config["region"], "use_unsigned_session": False}
```

### Specifying solid configuration

The `configured` API can be used with any definition type in the same way. To configure a solid, for
example, simply invoke `configured` on the solid definition:

```python file=/concepts/configuration/configured_solid_example.py
from dagster import Field, configured, solid


@solid(
    config_schema={"iterations": int, "word": Field(str, is_required=False, default_value="hello")}
)
def example_solid(context):
    for _ in range(context.solid_config["iterations"]):
        context.log.info(context.solid_config["word"])


# This example is fully configured. With this syntax, a name must be explicitly provided.
configured_example = configured(example_solid, name="configured_example")(
    {"iterations": 6, "word": "wheaties"}
)

# This example is partially configured: `iterations` is passed through
# The decorator yields a solid named 'another_configured_example' (from the decorated function)
# with `int` as the `config_schema`.
@configured(example_solid, int)
def another_configured_example(config):
    return {"iterations": config, "word": "wheaties"}
```

## Patterns

### <Check/> Reusing a solid definition with configured

When using the decorator syntax (`@configured`), the resulting solid definition will inherit the
name of the function being decorated (like `another_configured_example` in the above example). When
configuring a solid completely with a config dictionary rather than with a function (as with
`configured_example`), you must add the positional argument `name` in the call to `configured`.
When naming solids, remember that solid definitions must have unique names within a repository or
pipeline.

```python file=/concepts/configuration/configured_named_solid_example.py startafter=start_configured_named endbefore=end_configured_named
@solid(
    config_schema={
        "is_sample": Field(bool, is_required=False, default_value=False),
    },
    input_defs=[InputDefinition("xs", List[Int])],
)
def variance(context, xs):
    n = len(xs)
    mean = sum(xs) / n
    summed = sum((mean - x) ** 2 for x in xs)
    result = summed / (n - 1) if context.solid_config["is_sample"] else summed / n
    return result ** (1 / 2)


# If we want to use the same solid configured in multiple ways in the same pipeline,
# we have to specify unique names when configuring them:
sample_variance = configured(variance, name="sample_variance")({"is_sample": True})
population_variance = configured(variance, name="population_variance")({"is_sample": False})


@pipeline
def stats_pipeline():
    sample_variance()
    population_variance()
```
