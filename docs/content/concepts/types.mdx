---
title: Types | Dagster
description: The Dagster type system helps you describe what kind of values your solids accept and produce.
---

# Dagster Types

The Dagster type system helps you describe what kind of values your solids accept and produce.

## Relevant APIs

| Name                                                                           | Description                                                                 |
| ------------------------------------------------------------------------------ | --------------------------------------------------------------------------- |
| <PyObject module="dagster" object="DagsterType" />                             | Base class for dagster types.                                               |
| <PyObject module="dagster" object="PythonObjectDagsterType" />                 | A class for defining a Dagster Type whose typecheck is an isinstance check. |
| <PyObject module="dagster" object="check_dagster_type" />                      | The method to test a custom Dagster Type.                                   |
| <PyObject module="dagster" object="usable_as_dagster_type" decorator />        | A decorator to make a Python class usable as a Dagster Type.                |
| <PyObject module="dagster" object="make_python_type_usable_as_dagster_type" /> | A method to map an existing Python type to a Dagster Type.                  |

## Overview

Each solid input and output can be annotated with a Dagster Type.

The type system:

- Is _gradual_ and _optional_. Pipelines can run without types specified explicitly, and specifying types in some places doesn't require that types be specified everywhere. Inputs and outputs default to the <PyObject module="dagster" object="Any" /> type.

- Is independent from the [PEP 484](https://www.python.org/dev/peps/pep-0484/) Python type system. However, we overload the type annotation syntax on functions to make it easier to specify your solids' input and output types.

- Happens at solid execution time - each type defines a `type_check_fn` that knows how to check whether values match what it expects. When a type is specified for a solid's input, then the type check occurs immediately before the solid is executed. When a type is specified for a solid's output, then the type check occurs immediately after the solid is executed.

---

## Defining a Dagster Type

The core API for defining Dagster types is <PyObject module="dagster" object="DagsterType" />.

```python file=/concepts/types/types.py startafter=start_basic_even_type endbefore=end_basic_even_type
EvenDagsterType = DagsterType(
    name="EvenDagsterType",
    type_check_fn=lambda _, value: isinstance(value, int) and value % 2 is 0,
)
```

Once created, types can be attached to solid <PyObject module="dagster" object="InputDefinition" pluralize /> and <PyObject module="dagster" object="OutputDefinition" pluralize />.

```python file=/concepts/types/types.py startafter=start_basic_even_type_no_annotations endbefore=end_basic_even_type_no_annotations
@solid(
    input_defs=[InputDefinition("num", EvenDagsterType)],
    output_defs=[OutputDefinition(EvenDagsterType)],
)
def double_even(_, num):
    return num
```

Using Python 3 and type annotations, the same declaration can be expressed as:

```python file=/concepts/types/types.py startafter=start_basic_even_type_with_annotations endbefore=end_basic_even_type_with_annotations
@solid
def double_even_with_annotations(_, num: EvenDagsterType) -> EvenDagsterType:
    # These type annotations are a shorthand for constructing InputDefinitions
    # and OutputDefinitions, and are not mypy compliant
    return num  # at runtime this is a python int
```

When you pass raw DagsterTypes, it will not be compliant with Mypy or other Python static type-checking systems (we will refer to just Mypy throughout the remainder of this document for convenience). See details about how Dagster Types work with Mypy in [Mypy Compliance](#mypy-compliance).

### Scalar Types

Dagster exports top-level scalars -- <PyObject module="dagster" object="Int" />, <PyObject module="dagster" object="Bool" />, <PyObject module="dagster" object="String" />, <PyObject module="dagster" object="Float" /> -- that can be used as <PyObject module="dagster" object="DagsterType" /> instances. For convenience, you can use the corresponding python built-in scalars -- `int`, `bool`, `str`, `float` -- to specify the corresponding Dagster scalar types.

It also makes these arguments Mypy-compliant. There is a 1:1 relationship between the python type and its corresponding Dagster type, such as `int` and <PyObject module="dagster" object="Int" />. The Dagster system maintain a mapping between them. This means that you can use those Python types in <PyObject module="dagster" object="InputDefinition" pluralize /> or <PyObject module="dagster" object="OutputDefinition" pluralize />. If you pass them as type annotation to solids, the system can also pick up the corresponding DagsterType.

You can also define your own 1:1 relationships between python and Dagster types. See this pattern in [Python Types and Dagster Types](#python-types-and-dagster-types)

### Built-in Primitive Types

Here is a list of Dagster's built-in primitive types. You can find code examples of each type's usage in its API Reference:

- <PyObject module="dagster" object="Any" />: Use this type for any input,
  output, or config field whose type is unconstrained.
- <PyObject module="dagster" object="Bool" />: Use this type for any boolean
  input, output, or config_field.
- <PyObject module="dagster" object="Int" />: Use this type for any integer
  input or output.
- <PyObject module="dagster" object="Float" />: Use this type for any float
  input, output, or config value.
- <PyObject module="dagster" object="String" />: Use this type for any string
  input, output, or config value.
- <PyObject module="dagster" object="Optional" />: Use this type only for inputs
  and outputs, if the value can also be None.
- <PyObject module="dagster" object="List" />: Use this type for inputs, or
  outputs.
- <PyObject module="dagster" object="Dict" />: Use this type for inputs, or
  outputs that are dicts.
- <PyObject module="dagster" object="Set" />: Use this type for inputs, or
  outputs that are sets.
- <PyObject module="dagster" object="Tuple" />: Use this type for inputs or
  outputs that are tuples.
- <PyObject module="dagster" object="Nothing" />: Use this type only for inputs
  and outputs, in order to establish an execution dependency without
  communicating a value.

  See details in the [Nothing dependencies](/concepts/solids-pipelines/pipelines#order-based-dependencies-nothing-dependencies) example.

## Testing a Dagster Type

You can use <PyObject module="dagster" object="check_dagster_type" /> to test a custom Dagster Type:

```python file=/concepts/types/types.py startafter=start_test_dagster_type endbefore=end_test_dagster_type
from dagster import check_dagster_type, Dict, Any


def test_dagster_type():

    assert check_dagster_type(Dict[Any, Any], {"foo": "bar"}).success
```

## Examples

### \`isinstance\` Type Checking

It is common to define types that just do _isinstance_ checks as the Dagster type check. <PyObject module="dagster" object="PythonObjectDagsterType" /> does just that.

```python file=/concepts/types/object_type.py startafter=start_object_type endbefore=end_object_type
class EvenType:
    def __init__(self, num):
        assert num % 2 is 0
        self.num = num


EvenDagsterType = PythonObjectDagsterType(EvenType, name="EvenDagsterType")
```

You can now declare the Dagster type as the interface to the solid and use the corresponding python type in business logic.

```python file=/concepts/types/object_type.py startafter=start_use_object_type endbefore=end_use_object_type
@solid
def double_even(_, even_num: EvenDagsterType) -> EvenDagsterType:
    return EvenType(even_num.num * 2)
```

The type system truly shines once the type check expresses richer behavior, such as column-level schema on a dataframe. For example, check out the [Validating Pandas DataFrames with Dagster Types](/integrations/pandas) guide.

## Patterns

### Python Types and Dagster Types

As alluded to earlier, you can define your own 1:1 relationships between Python types and Dagster types. It makes the corresponding Python type usable where the Dagster type is expected.

This is convenient when you have business objects that require nothing more than an `isinstance` check in the Dagster type check _and_ you want to use them both in type annotations directly and as business objects. These type definitions reduce boilerplate as well as deliver out-of-the-box mypy compliance.

There are two APIs:

- <PyObject module="dagster" object="usable_as_dagster_type" decorator /> for direct
  annotations of class declarations.
- <PyObject module="dagster" object="make_python_type_usable_as_dagster_type" /> for
  mapping existing classes.

This is designed for importing python types libraries that cannot be altered and mapping them to Dagster types.

#### Decorating class declarations

```python file=/concepts/types/usable_as.py
from dagster import solid, usable_as_dagster_type


@usable_as_dagster_type
class EvenType:
    def __init__(self, num):
        assert num % 2 is 0
        self.num = num


@solid
def double_even(_, even_num: EvenType) -> EvenType:
    return EvenType(even_num.num * 2)
```

#### Mapping existing classes

```python file=/concepts/types/make_usable.py
from dagster import PythonObjectDagsterType, make_python_type_usable_as_dagster_type, solid


class EvenType:
    def __init__(self, num):
        assert num % 2 is 0
        self.num = num


EvenDagsterType = PythonObjectDagsterType(EvenType, name="EvenDagsterType")

make_python_type_usable_as_dagster_type(EvenType, EvenDagsterType)


@solid
def double_even(_, even_num: EvenType) -> EvenType:
    return EvenType(even_num.num * 2)
```

However, this approach does have downsides. Importing these types will causes a global side effect as there is an internal registry which manages these types. This can introduce challenges in terms of testability and also can cause changes in behavior based on import order.

Additionally some of the most useful patterns in the ecosystem are to use type factories to programmatically create Dagster types, such as in our dagster-pandas module. In these cases a 1:1 mapping between dagster type and python type _no longer exists_. E.g. in dagster-pandas the python representation for all the dataframe variants is simply _pandas.DataFrame_.

For clearly scoped business objects, the reduction in boilerplate is significant and eases mypy compliance, hence its inclusion in the public Dagster API.

We do _not_ recommend that libraries use this pattern and instead rely on other techniques to achieve mypy compliance.

#### MyPy Compliance

Users who do not use "usable-as-dagster" python types types by choice or necessity and who desire mypy compliance need additional support.

This is a challenge to do elegantly in light of the fact that, as of mypy 0.761, there is no way to directly annotate an object to treat it as a type during a type checking pass. However there is a way to do this.

```python file=/concepts/types/mypy.py
import typing

from dagster import PythonObjectDagsterType, solid


class EvenType:
    def __init__(self, num):
        assert num % 2 is 0
        self.num = num


if typing.TYPE_CHECKING:
    EvenDagsterType = EvenType
else:
    EvenDagsterType = PythonObjectDagsterType(EvenType)


@solid
def double_even(_, even_num: EvenDagsterType) -> EvenDagsterType:
    return EvenType(even_num.num * 2)
```

While not particularly elegant, this does work. We recommend centralizing type definitions so that this style of the definition is compartmentalized to a single file.
